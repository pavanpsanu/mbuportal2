import { __awaiter } from "tslib";
export const fileToArray = (url) => {
    return new Promise((resolve, reject) => {
        try {
            const request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.responseType = 'blob';
            request.onload = () => {
                const reader = new FileReader();
                reader.readAsArrayBuffer(request.response);
                reader.onloadend = () => {
                    resolve(reader.result);
                };
            };
            request.send();
        }
        catch (_a) {
            reject(`error while retrieving file ${url}.`);
        }
    });
};
const reloadIFrame = (iframe) => {
    if (iframe) {
        console.log('reloading..');
        // eslint-disable-next-line no-self-assign
        iframe.src = iframe.src;
    }
};
const ɵ0 = reloadIFrame;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const handleFileUpload = (fileInput) => {
    return new Promise((resolve, reject) => {
        if (fileInput.target.files && fileInput.target.files[0]) {
            const reader = new FileReader();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            reader.onload = (e) => {
                resolve(e.target.result);
            };
            reader.readAsDataURL(fileInput.target.files[0]);
        }
        else {
            reject('no files selected');
        }
    });
};
export const getbaseUrl = () => {
    const pathArray = window.location.href.split('/');
    const protocol = pathArray[0];
    const host = pathArray[2];
    return protocol + '//' + host;
};
export const getLocation = (href) => {
    const match = href.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)([\/]{0,1}[^?#]*)(\?[^#]*|)(#.*|)$/);
    return match && {
        href,
        protocol: match[1],
        host: match[2],
        hostname: match[3],
        port: match[4],
        pathname: match[5],
        search: match[6],
        hash: match[7]
    };
};
export const getDocxToHtml = (url) => __awaiter(void 0, void 0, void 0, function* () {
    if (!mammoth) {
        console.error('Please install mammoth and make sure mammoth.browser.min.js is loaded.');
    }
    const arrayBuffer = yield fileToArray(url);
    const resultObject = yield mammoth.convertToHtml({ arrayBuffer });
    return resultObject.value;
});
export const googleCheckSubscription = () => {
    let subscription = null;
    let checkCount = 0;
    return {
        subscribe: (iframe, interval = 3000, maxChecks = 5) => {
            if (!iframeIsLoaded(iframe)) {
                subscription = setInterval(() => {
                    checkCount++;
                    if (checkCount >= maxChecks) {
                        clearInterval(subscription);
                    }
                    reloadIFrame(iframe);
                }, interval);
                return subscription;
            }
            else {
                if (subscription) {
                    clearInterval(subscription);
                }
            }
        },
        unsubscribe: () => {
            if (subscription) {
                clearInterval(subscription);
            }
        },
    };
};
export const iframeIsLoaded = (iframe) => {
    var _a;
    // its #document <html><head></head><body></body></html> when google is returning a 204
    // so if contentDocument = null then it's loaded.
    let isLoaded = false;
    try {
        if (!internetExplorer()) {
            isLoaded = !(iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument);
        }
        else {
            isLoaded = !((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentWindow) === null || _a === void 0 ? void 0 : _a.document);
        }
    }
    catch (_b) {
        // ignore message Blocked a frame with origin "http://..." from accessing a cross-origin frame.
    }
    return isLoaded;
};
const internetExplorer = () => (/MSIE (\d+\.\d+);/.test(navigator.userAgent) || navigator.userAgent.indexOf("Trident/") > -1);
const ɵ1 = internetExplorer;
export const getViewerDetails = (url, configuredViewer = 'google', queryParams = '', viewerUrl = '') => {
    switch (configuredViewer) {
        case 'google':
            viewerUrl = `https://docs.google.com/gview?url=%URL%&embedded=true`;
            break;
        case 'office': {
            viewerUrl = `https://view.officeapps.live.com/op/embed.aspx?src=%URL%`;
            break;
        }
        case 'pdf': {
            viewerUrl = '';
            break;
        }
    }
    const externalViewer = configuredViewer === 'google' ||
        configuredViewer === 'office' ||
        configuredViewer === 'url';
    const u = (url === null || url === void 0 ? void 0 : url.indexOf('/')) ? encodeURIComponent(url) : url;
    let fullUrl = viewerUrl ? viewerUrl.replace('%URL%', u) : url;
    if (queryParams && externalViewer && configuredViewer !== 'url') {
        const start = queryParams.startsWith('&') ? '' : '&';
        fullUrl = `${fullUrl}${start}${queryParams}`;
    }
    return {
        url: fullUrl,
        externalViewer,
    };
};
export const replaceLocalUrl = (url, overrideLocalhost) => {
    const loc = getLocation(url);
    const locReplace = getLocation(overrideLocalhost);
    if (loc && locReplace) {
        return url.replace(loc.port ? `${loc.hostname}:${loc.port}` : loc.hostname, locReplace.port ? `${locReplace.hostname}:${locReplace.port}` : locReplace.hostname);
    }
    return url;
};
const getBlobFromUrl = (url) => {
    return new Promise((resolve, reject) => {
        let request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.responseType = 'blob';
        request.onload = () => {
            resolve(request.response);
        };
        request.onerror = reject;
        request.send();
    });
};
const ɵ2 = getBlobFromUrl;
export const uploadToCloud = (fileUrl, api) => new Promise((resolve, reject) => {
    getBlobFromUrl(fileUrl).then(blob => {
        var _a, _b;
        const loc = getLocation(fileUrl);
        const name = (loc === null || loc === void 0 ? void 0 : loc.pathname) ? (_a = loc === null || loc === void 0 ? void 0 : loc.pathname) === null || _a === void 0 ? void 0 : _a.split('/')[((_b = loc === null || loc === void 0 ? void 0 : loc.pathname) === null || _b === void 0 ? void 0 : _b.split('/').length) - 1] : '';
        const formData = new FormData();
        const request = new XMLHttpRequest();
        formData.append('file', blob, name);
        request.onreadystatechange = e => {
            if (request.readyState === XMLHttpRequest.DONE) {
                if (request.status === 200) {
                    resolve(request.responseText);
                }
                else {
                    reject(request.responseText);
                }
            }
        };
        request.onerror = reject;
        request.open('post', api, true);
        request.send(formData);
    });
});
export const isLocalFile = (file) => {
    const loc = getLocation(file);
    const hostname = (loc === null || loc === void 0 ? void 0 : loc.hostname) || '';
    return ((['localhost', '127.0.0.1', '', '::1'].includes(hostname))
        || (hostname.startsWith('192.168.'))
        || (hostname.startsWith('10.0.'))
        || (hostname.endsWith('.local')));
};
export { ɵ0, ɵ1, ɵ2 };
//# sourceMappingURL=helper.js.map